[{"title":"图片上传本地预览实现（兼容IE8）","date":"2017-05-10T02:09:59.000Z","path":"2017/05/10/图片上传本地预览实现(兼容IE8)/","text":"最近项目里需要用到上传图片并预览的功能，于是写了个jQuery预览图片插件，兼容IE8,下载地址。有需要的，可以直接下载。第一次写jQuery插件，如有不对之处，欢迎大家指正。下面是一些相关的知识点笔记。 HTML5 File API在HTML5 File API出现前，前端对于文件的操作的非常有局限性的。出于安全角度考虑，从本地上传文件时，代码是不可能获取文件在用户本地的地址。但是File API的出现，实现了这一功能。File API主要有以下几个接口： Blob File FileList FileReader FileList API当通过file控件获取文件后，可以通过该控件的files属性得到FileList对象。FileList对象里保存着选择的文件，即File对象。在MDN里有如下提示： 在Gecko 1.9.2之前,通过input元素,每次只能选择一个文件,这意味着该input元素的files属性上的FileList对象只能包含一个文件.从Gecko1.9.2开始,如果一个input元素拥有multiple属性,则可以用它来选择多个文件. 因此需要注意，在默认状态下选择文件，每次FileList对象里只有一个File文件。以上传图片为例。File对象保存了“name”,”size”,”type”等图片的信息。12&lt;input id=&quot;fileItem&quot; type=&quot;file&quot;&gt;var file = document.getElementById(&apos;fileItem&apos;).files[0]; FileReader API实现本地图片预览FileReader用来异步读取本地文件FileReader对象允许web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容。我们可以通过FileList获取上传的图片相关信息，但是想要实现本地预览还需要借助FileReader来实现,FileReader可以读取本地图片，并将图片数据转换成base64编码的字符串形式嵌入到页面中。1234//创建一个FileReader对象var reader = new FileReader();//读取file文件；reader.readAsDataURL(file); FileReader提供了几个方法，如readAsText(),readAsDataURL(),readAsArrayBuffer()，分别表示用不同的数据格式来读取上传的文件，并将结果保存在result属性里。在读取本地文件的过程中，FileReader提供了一些事件可供监听。如onprogress,onload,onerror,onabort等。在上传图片的过程中，常用到的有onprogress事件在读取数据过程中周期性调用，可以用来实现上传进度条效果，onload事件，当读取操作成功完成时调用。在我们实现上传图片的效果里，就有用到。1234//当文件读取成功后，将结果保存到url变量里；reader.onload = function(evt) &#123; var url = evt.target.result;&#125; 最后，将该url赋值给img元素的src属性，便可以实现本地图片预览了。关于兼容性，不兼容IE9及以下浏览器，其它主流浏览器一般都没有问题。 HTML5 URL APIURL对象用于生成指向File对象或者Blob对象的URL。使用URL的好处是可以不必把文件内容读取到JavaScript中而可以直接使用文件内容。如果通过URL对象来实现本地预览，那么只需将生成的File对象的URL传递给img元素的src属性即可。 当使用一个没有实现该构造器的用户代理时，可以通过 Window.URL属性来访问该对象（基于 Webkit 和 Blink 内核的浏览器均可用 Window.webkitURL代替）。 1var url = window.URL || window.webkitURL; createObjectURL()实现本地图片预览URL对象有两个方法，分别是createObjectURL()和revokeObjectURL()。 createObjectURL()的作用生成文件File对象或者Blob对象的URL对象，通过这个URL，可以访问到URL所指向文件的整个内容。1var src = url.createObjectURL(file); 在每次调用createObjectURL()方法的时候,都会创建一个新的对象URL,即使你已经用相同的对象作为参数创建过。在你不需要这些对象URL的时候,你应该通过调用 window.URL.revokeObjectURL()方法来释放它们所占用的内容。 revokeOjectURL()的用法1url.revokeObjectURL(src); 参数src是上述我们通过createObjectURL创建的URL对象。关于兼容性，不兼容IE9及以下浏览器，其它主流浏览器一般都没有问题。在MDN里提到，这是一个实验中的功能。 h5 FormData对象上传图片HTML5提出了XMLHttpRequest对象的第二版，从此ajax能够上传文件了。这是真正的”异步上传”，是将来的主流。我们主要用的是FormData对象，它能够构建类似表单的键值对。 ajax上传代码，放在表单的submit事件回调函数中：123form.on(&apos;submit&apos;,function() &#123; // 此处进行ajax上传&#125;); 图片预览兼容IE处理IE9及以下版本不支持File API和URL API。因此需要做兼容处理。在这里，我们需要用到document.selection。document.selection只有IE支持。代表了当前激活选中区，即高亮文本块，和/或文档中用户可执行某些操作的其它元素。selection 对象的典型用途是作为用户的输入，以便识别正在对文档的哪一部分正在处理，或者作为某一操作的结果输出给用户。在用document.selection前，我们需要先创建选中区。如鼠标选中文本框，即是一个选中区。也可以通过js提供的select()方法创建一个选中区。创建了选中区后，我们就可以通过document.selection获取该选中区。如果要对选中区执行操作，则需要先调用createRange()方法。123//获取上传文件控件的值；file.select();var url = document.selection.createRange().text; 现有的获取IE低版本上传文件的value值一般都是这种方式，在IE中原本可以直接通过input的value值来获取上传图片的路径，但是在实际中很少看到使用。具体的大家可以去查查资料。非IE6版本的IE由于安全问题直接设置img的src无法显示本地图片，但是可以通过滤镜来实现。1pic.style.filter = &quot;progid:DXImageTransform.Microsoft.AlphaImageLoader(sizingMethod=&apos;scale&apos;,src=\\&quot;&quot; + reallocalpath + &quot;\\&quot;)&quot;; 到这里，图片本地预览基本就完成了。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"css动画里的steps()用法详解【译】","date":"2017-03-30T07:53:40.000Z","path":"2017/03/30/css动画里的steps()用法详解/","text":"原文地址：http://designmodo.com/steps-css-animations/原文作者：Joni Trythall 我想你在css 动画里使用steps()会和我一样有很多困惑。一开始我不清楚怎样使用它，于是搜索出了两个案例：typing demo by Lea Verou 和 animated sprite sheet by Simurai.这些例子很棒，帮助我开始理解这个特别的timming function，但是它们是如此优秀的例子，以至于在demo之外还是难以理解怎样使用steps()。所以，我仔细研究了steps()并且做了一些动画demos用来帮助理解一些难点。 steps介绍steps()是一个timing function，允许我们将动画或者过渡分割成段，而不是从一种状态持续到另一种状态的过渡。这个函数有两个参数——第一个参数是一个正值，指定我们希望动画分割的段数。 Steps(，) 第二个参数定义了这个要点 在我们的@keyframes中申明的动作将会发生的关键。这个值是可选的，在没有传递参数时，默认为”end”。方向为”start”表示一个左–持续函数，在动画开始时，动画的第一段将会马上完成。以左侧端点为起点，立即跳到第一个step的结尾处。它会立即跳到第一段的结束并且保持这样的状态直到第一步的持续时间结束。后面的每一帧都将按照此模式来完成动画。 方向为”end”表示一个右–持续函数。动画执行时，在每一帧里，动画保持当前状态直到这一段的持续时间完成，才会跳到下一步的起点，后面的每一帧都按照这个模式来进行，在最后一帧的起点，等到这一帧的持续时间结束，整个动画的执行也已经结束，执行动画的元素来不及跳到这一帧的终点，直接回到了整个动画起点，开始了第二次动画。每个选择本质上从一个不同的面移动这个元素并且将产生一个不同的位置在这个相同的动画里。这面是示例图： 动态解析图如下： 填充模式和迭代次数的影响#在我们开始前，明白一个不同的填充模式或者迭代次数将会怎样影响steps()是非常重要的，例如”forwards”或者”infinite”的使用。如果我们有两辆车，使用相同的动画持续时间、相同的steps()值，但是其中一个设置（infinite），另一个填充（forward）,终点的这两辆汽车看起来非常不同，即使他们从相同的轴点出发。 “forwards”的命令使这个动画元素保持着@keyframes里最后一个动画样式。在动画，里将它与steps()联系使这个动作出现，好像初始的静止状态没有计算到总的步数里。当它是”end”，好像这个车行驶了额外的步数超出了你的steps()的声明，取决于你怎样看待它。 这些讲解听起来还是很散乱，但是我们将在demos里慢慢讲解。（demo地址：）现在最重要的事情是留心这些变化将会怎样影响你的意图和steps数。下面是infinite VS forwards车： steps demos你可以点击这里查看demos,它由以下几个部分组成： 纯css实现的闹钟 一些节能的css车 前进的熊爪印 纯css实现的进度圆 css闹钟 一个应用了steps()的闹钟演示。我们需要闹钟的指针旋转起来，但是不是圆滑连续的运动。使用steps()将允许我们模仿真实的闹钟的运动。 这里涉及到了一些数学知识，但是还不是很痛苦。我们需要秒针通过60步完成360度的旋转在60s的时间里。 分针我们可以应用相同的@keyframes,只有改变动画的执行时间即可。分针转一圈，为3600s,即分针在3600s里，完成60步。 申明：这只是一个css闹钟，并不能依赖这个闹钟来执行你的日常活动。 css cars css车演示了在steps()里使用”end”和”start”的不同。”start”使小车立即移动到一步的结束处并保持当前状态直到这一步的持续时间结束。看起来就好像使用了”start”的车的位置比使用”end”的车的位置更远，但是如果你给这两辆小车添加一个动画的延迟，你可以看到它们是从相同的起点出发的。 “end”会等到每一步的执行时间结束才会开始动画。第一辆车移动的时候，这是它的第二步，所以这两辆车没有机会同步移动。动画里白色的边框是动画当前的起始位置。 熊脚印 另一种更好的理解stpes()的方法是创建真实的步数。这个案例我们将会使用熊脚印。这个演示使用了由六个脚印组成的图片。这个图片被一个&lt;div&gt;覆盖，我们要用steps()移动这个&lt;div&gt;来显示出脚印，用来模仿实际的脚印。 没有使用steps()时，&lt;div&gt;将平滑的向右移动，这不是我们想要的效果。我们希望每个脚印可以立即完整的出现。 有六个脚印，我们需要向右移动&lt;div&gt;的长度为图片的整个宽度。 我们的&lt;div&gt;将向右移动675px在7秒7步的时间里。每一步是96px宽。”end”表示我们的动画将保持它的初始状态，覆盖扬剧有的脚印直到第一步完成。 css进度圆 在这个演示里我们使用”start”来动态改变不透明度。使用”start”制作一个百分比的可见度的变化。 所有的百分数在同一个&lt;div&gt;里，我们将这个&lt;div&gt;通过动画向上移动380px；初始值是”20%”,我们需要通过四步移动&lt;div&gt;使数值为40%,60%,80%到最后的100%。 再次强调，使用”forwards”和”infinite”对步数的的作用是不同的。如果我们改变成”infinite”，将不会出现”100%”,因为”forwards”命令使动画在我们设置的步数外添加了额外的一步。”forwards”使动画保持结束时的状态，所以在步数执行完毕后，动画会跳到最后一帧的状态并保持不变。 结束语steps() timing function确实难以理解，但是一旦你掌握它了，就会有很多便利。css function 允许我们将动画切割成清楚的步数，或者创建平滑的动画效果。希望这些demos可以帮助你在动画里更好的理解使用steps()。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"实现一个函数对js里主要的数据类型进行值复制","date":"2017-03-29T01:27:58.000Z","path":"2017/03/29/实现一个函数对js里主要的数据类型进行值复制/","text":"问题：实现一个函数clone，可以对js里五种主要的数据类型进行值复制？考察点： 对于基本数据类型和引用数据类型在内存中存放的是值还是引用这一区别是否清楚； 怎样判断一个变量的类型； 递归算法的设计； 代码：12345678910111213141516function clone(obj)&#123; var obj2=&#123;&#125;; if (typeof obj !== &apos;object&apos;||obj==&apos;&apos;) &#123; return obj; &#125;else if (Object.prototype.toString.call(obj)==&apos;[object Array]&apos;) &#123; obj2=[]; for(var i in obj)&#123; obj2[i]=arguments.callee(obj[i]); &#125; &#125;else&#123; for(var i in obj)&#123; obj2[i]=arguments.callee(obj[i]); &#125; &#125; return obj2; &#125; 下面逐一来讲解考察知识点。 不同数据类型值的保存方式js数据类型分为基本数据类型和引用数据类型。基本数据类型有string,number,boolean,undefined,null。引用数据类型有object。 基本数据类型是以值的方式保存在内存中的。如1234var a = 1;var b = a;a = 2;console.log(b); 在这里，将a的值赋给b后，在内存中会新增空间存放这个值”1”。将a的值重置为2后，它对b是没有影响的，a和b的值是单独存储的。因此b依然为1。 在引用数据类型里，它传递的是关于对象的引用。1234var a = &#123;name:&apos;bird&apos;,age:12&#125;;var b = a;a.name = &apos;cat&apos;;console.log(b.name); 在这里，打印的结果是’cat’。变量a里保存的是对象的一个引用，当把a的值赋给b时，只是把这个引用赋给了b，它们都指向同一个内存。因此当重置a.name后，b.name也发生改变了。就像取昵称，你向不同的人展示不同的昵称，可是你这个人是独一无二的。 在我们这个问题里，要对不同数据类型的值进行复制，上面我们说了，引用数据类型如果直接赋给一个变量，它实际上复制的是引用。因此，我们需要将基本数据类型与引用数据类型分开复制。那么怎么判断一个变量的数据类型呢？ 判断变量的数据类型typeof基本数据类型可以通过”typeof”关键字来检查类型。typeof可返回如下值：”string,number,boolean,undefined,object,function”。其中”typeof null”返回的是”object”。 instanceofinstanceof用来判断一个变量是否是某个对象的实例。如12var a = new Object();a instanceof Object; //true 检测数组的方法通过”typeof”筛选出数据类型不是”object”或为null的数据，这些数据类型的数据在内存中存放的是值，因此可以直接return返回；剩下的有对象和数组，我们需要进一步区分。那么如何检测数组呢？ ECMAScript5的isArray函数 ECMAScript提供的Array.isArray(obj)可以用来检测一个对象是否是数组； 12var a = [1,2];Array.isArray(a); //true 这种方式检测数组的唯一缺陷是它的兼容性。IE9+、Firefox4+、Safari5+、Opera10.5+和Chrome都实现了这个方法，但是在IE8之前的版本是不支持的。 通过constructor属性来检测 对象都有一个constructor属性，指向它的构造函数。对于数组来说，它的内建对象是Array。通过该属性也可以检测数组类型。 12var a = [1,2];console.log(a.constructor == Array); //true instanceof操作符 instanceof操作符用来判断前面的对象是否是后面的类或对象的实例。 12var a = [1,2];console.log(a instanceof Array); 不过在有iframe存在时会出现问题。当你在多个frame中来回跳时，constructor和instanceof就不管用了。由于每一个frame都有自己的执行环境，跨frame实例化的对象彼此并不共享原型链，通过instanceof操作符和constructor属性检测的方法自然会失败。如下： 123456var iframe = document.createElement(&quot;iframe&quot;); //创建一个&quot;iframe&quot;标签document.body.appendChild(iframe); //将iframe添加到body里otherArray = window.frames[window.frames.length - 1].Array;//获取Array构造函数；var arr = new otherArray(&quot;1&quot;,&quot;2&quot;); //在iframe里实例化一个arr数组；console.log(arr instanceof Array); //falseconsole.log(arr instanceof otherArray); //true 因为arr数组是在框架里创建的，它是从iframe里的Array构造函数实例化而来（otherArray）的。 对象原生toString检测通过Object.prototype.toString来检测，它的工作原理是，先取得对象的一个内部属性[[Class]]，然后依据这个属性，返回一个类似于”[object Array]”的字符串作为结果（[[]]表示语言内部用到的、外部不可直接访问的属性）。利用这个方法，再配合call，我们可以取得任何对象的内部属性[[Class]]。然后把类型检测转化为字符串比较，以达到我们的目的。为什么不直接obj.toString()呢？虽然Array继承自Object（所有对象都继承Object()），内部也有toString方法，但是这个方法可能被改写达达不到我们的要求。检测数组方法可以参考(Javascript学习笔记：检测数组方法)[https://www.w3cplus.com/javascript/array-part-2.html] 这篇文章。 递归算法在程序中，递归就是函数直接调用自己或者间接调用自己。在我们这个题目里，通过for…in来遍历数组或对象。通过arguments.callee()来接收一个属性值，arguments.callee()的作用是调用当前正在执行的函数，也就是clone(obj)。这一操作的作用是，属性值可以是任何数据类型，它可能是一个对象，如果直接obj2[i] = obj[i]，那么复制的就是对象的引用了。所以我们需要对这个值再进行一次深度复制。即通过arguments.callee()来调用当前执行的函数。123for(var i in obj) &#123; obj2[i]=arguments.callee(obj[i]); &#125; 递归算法可以参考javascript递归算法的初步认识及使用技巧这篇文章。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"正则学习笔记","date":"2017-03-28T03:10:40.000Z","path":"2017/03/28/正则学习笔记/","text":"REGEXP对象JS通过内置对象RegExp支持正则表达式，有两种方法实例化RegExp对象。 ● 字面量：var test = /a/; ● 构造函数：var test = new RegExp(匹配模式，修饰符); 如：var reg = new EegExp(&#39;\\\\bis\\\\b&#39;,&#39;g&#39;); 其中’\\b’表示单词边界，前面再加上’\\’用来转义。 定界符定界符可以是除字母数字或反斜杠外的任何字符，必须使用相同的字符来标记模式的开始和结束，通常，我们看到的都是使用的正斜杠，如/a/。 修饰符模式修饰符不同于其他的字符，它们放在结束定界符之后。g : global全文搜索，不添加该修饰符时，搜索到第一个即停止匹配。i : ignore case忽略大小写，不添加该修饰符时，大小写敏感。m : multiple lines多行搜索。 字符正则表达式由两种基本字符类型组成，字面量字符和元字符。 字面量字符字面量字符是一个值，它的书写方式与所解释的完全一样。如/ab/用来匹配’ab’字符串。 元字符元字符是有特殊含义的符号。如：. ? + * $ ^ | () {} [] | \\ 字符类 字符类字符类是通过把字符放置在方括号（[]）内创建的。所谓类是指符合某些特征的对象，一个泛指，而不是特指某个字符。例如，表达式[abc]把字符a或b或c归为一类，表达式可以匹配其中a,b,c任一个即匹配成功。注意：[^abc]的前括号加了一个”^”，表示取反，即匹配不为括号里的字符。 范围类如[a-z]表示匹配a到z的任意字符。[0-9]表示匹配0到9的任意数字。 预定义类| 字符 | 类 | 描述 || . | [^\\n\\r] | 匹配除了换行和回车外的任意字符 || \\d | [0-9] | 匹配数字字符 || \\D | [^0-9] | 匹配非数字字符 || \\s | [\\t\\n\\x0B\\f\\r] | 匹配空白字符 || \\S | [^\\t\\n\\x0B\\f\\r] | 匹配非空白字符 || \\w | [0-9_a-zA-Z] | 匹配单词字符 || \\W | [^a-zA-Z_0-9] | 非单词字符 |边界匹配字符 量词由于元字符、特殊字符、字符类都是一对一进行匹配的，如12var a = &apos;abcd26&apos;;var b = a.replace(/../,&apos;1&apos;); // 1cd26 如果需要匹配的字符串过长，这样的写法将会很麻烦，我们可以通过量词，来限定匹配的次数。注意：量词作用于它前面的字符匹配。如12var a = &apos;abcd26&apos;;var b = a.replace(/.&#123;2&#125;/,&apos;1&apos;); // 1cd26 {2}——匹配2次{2,}——至少匹配2次{2,5}——匹配2到5次？——匹配0次或1次*——匹配0次或多次+——匹配1次或多次 贪婪模式与非贪婪模式用{3,6}来匹配12345678的结果？正则默认尽可能多的匹配（贪婪模式），在这里它会匹配123456；在非贪婪模式里，它只匹配123就会停止匹配，如果加了’g’全局匹配修饰符的话，会全局匹配即结果为’123’,’456’非贪婪模式：让正则表达式尽可能少的匹配，一旦匹配成功即停止尝试匹配。使用非贪婪模式在量词后面加上’?‘即可。 分组使用()可以达到分组的功能，使量词作用于分组。而不只是某一个字符。如一个模式里有三个分组，则分别对应$1,$2,$3。$1,$2,$3的值分别是对应的匹配结果。 RegExp对象属性一个正则表达式对象拥有以下属性： global:默认值为false，即不进行全局匹配。如果需要进行全局匹配，设置成true即可。 ignoreCase:默认值为false，即区分大小写匹配。如果需要忽略大小写，设置成true即可。 multiline:默认值为false，即不进行跨行搜索。 lastIndex:搜索开始的索引位，默认值为0。 source:用于存储正则表达式匹配模式的属性。 除了lastIndex外，其它属性在对象创建后就不能再修改了。 前三个属性是可以用修饰符来表示的。如上面所示的”g”,”i”,”m”。只要它们被传递给了构造器，相应的修饰符就会被设置为true。 RegExp对象方法RegExp对象中有两种可用于查找匹配的方法：test()和exec()。 String.test(/匹配模式/)——返回一个布尔值，如果找到匹配的内容，则返回true，否则返回false。 exec()——返回一个由匹配字符串组成的数组。以正则表达式为参数的字符串方法在String对象中，以正则表达式对象为参数的方法主要有以下这些： match()——返回的是一个包含匹配内容的数组； search()——返回的是第一个匹配内容所在的索引位置； replace(匹配模式，替换内容)——该方法能将匹配的文本替换成指定的字符串；如果希望在匹配文本前后添加某些其它内容，可以使用”$&amp;”。如：a = 'abc13ds326';1alert(a.replace(/[a-z]/g,&apos;$&amp;_&apos;)); //a_b_c_13d_s_326 如果正则表达式中分了组，那么可以使用$1来表示第一组，$2来表示第二组，以此类推。 split()——能根据指定的正则表达式将目标字符串分割成若干个数组元素；","tags":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/正则/"}]},{"title":"Hello World","date":"2017-03-17T07:26:58.000Z","path":"2017/03/17/hello-world/","text":"折腾了两三天，这个博客终于成型了。这是我的第一个个人博客，这个一个完全属于我的空间。要学习的东西还很多，要走的路还很长，特写此文，记录迈出的第一步。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]
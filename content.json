[{"title":"hexo搭建博客过程","date":"2017-03-18T07:26:58.000Z","path":"2017/03/18/hexo搭建博客过程/","text":"其实hexo搭建博客超级简单。不过因为开始对这个不熟悉，跟着网上找到的教程操作反而入了很多坑。这篇文章算是做个总结吧。下面分几个阶段逐渐由简入深来讲解。 快速熟悉hexohexo博客成型 打开hexo官方文档，根据”安装前提”检查是否已经安装需要的应用程序。都安装好了后，按照文档上的步骤建站。 执行完上面命令后，接着执行以下命令，这行命令的作用是生成我们在浏览器里看到的html静态文件。$ hexo generate该命令可以简写为$ hexo g 怎么在本地查看这些页面呢？那么需要搭建一个服务器。hexo提供了”hexo-server”模块，通过以下命令来安装。$ npm install hexo-server --save安装完成后，在命令行里输入以下命令可启动服务器$ hexo server执行完命令后，在浏览器里输入 http://localhost:4000 即可查看网站。在服务器启动期间，hexo会监视文件变动并自动更新，您无须重启服务器。注意：有时在端口4000下很长时间无法加载出页面，此时可以试着更换端口。如下：$ npm server -p 5000完成上述步骤后，在浏览器里可以看到如下界面： 一个hexo默认的博客已经成型了。 配置博客默认博客生成了，那么怎么将它变成你的个人定制博客呢？我们需要对生成的 _config.yml 文件进行修改。具体可查看文档里的配置章节。这里有点需要注意的是，键值对中，冒号后面跟一个空格即可。除了常规配置外，hexo还为我们提供了很多 Hexo主题。根据自己的喜好选择主题，clone下来的主题会在themes文件夹里。将根目录下的_config.yml里的theme值修改成你选择要应用的主题名，然后进入到themes相应主题里，对主题里的_config.yml进行配置。这些工作都完成后了该怎么来查看效果呢？我们先用$ hexo clean清理已经生成的静态文件，然后执行$ hexo g$ npm server -p 5000在浏览器里就可以查看啦。 将hexo部署到github到目前为止，我们的个人博客只能在本地查看，怎么实现通过域名来访问个人博客呢？当然可以通过购买域名和空间来实现，我们也可以利用GitHub免费实现。GitHub为每一个用户分配了一个二级域名.github.io，用户为自己的二级域名创建主页很容易，只要在托管空间下创建一个名为.github.io的版本库，向其master分支提交网站静态页面即可。需要注意的一个是，是你的用户名。创建好了版本库，接下来就是要把生成的静态页面部署到GitHub版本库上了。打开根目录下的_config.yml文件，找到deploy设置如下,根据你的用户名来设置。注意空格缩进。1234deploy: type: git repo: git@github.com:&lt;user-id&gt;/&lt;user-id&gt;.github.io.git branch: master 到目前，准备工作已经全部完成。在Git Bash里输入：123$ hexo clean$ hexo g$hexo d 如果看到”Deploy done: git”即表示部署成功。打开GitHub里.github.io版本库，找到”Settings”，点击进去，在”GitHub Pages”模块，有”Your site is published at ……”，点击这个链接，即可查看你部署成功后的博客。 给博客绑定个人域名通过GitHub主页来访问，域名有些长，而且一看就知道是存放Github上。可能我们会想绑定自己的独立域名，拥有属于自己的独立博客。前提当然是你有个已经购买了的域名。我是在腾讯云买的域名，下面就讲讲在腾讯云里怎么设置。登录后，找到“云解析”模块，选择你要解析的域名，在操作里点击“解析”——“添加记录”。记录类型选择”CNAME”，它的作用是将域名指向另一个域名。主机记录默认，记录值填GitHub提供的个人主页域名，如”yang.github.io”。其它默认，保存。再添加一个记录，主机记录填写”www”，其它同上，保存。回到GitHub里.github.io版本库，在右上角点击”Create new file”，将文件命名为”CNAME”，里面写入你刚才解析过的域名。如：”auraty.com”。等10分钟后，在浏览器里就可以直接通过”auraty.com”来访问我的个人博客啦。 写文章会遇到的坑插入图片GitHub为个人提供了300M的免费空间，如果博客图片很多的话，加载会很慢，空间内存不够。而且HTTP并行下载的资源数量一般为10个左右，所以建议将网站资源放在多个域名中。因此我们可以将代码保存在GitHub中，将照片放在七牛中。你可以通过邀请链接进行注册，注册完成后，在“资源主页”里选择“对象存储”——“立即添加”，输入相关信息后保存即建好了存储空间。回到我们的博客源码所在文件夹，我在这里使用的是网上的一个hexo插件hexo-qiniu-syn，它的作用是将图片、js、css等一些静态文件上传到七牛的存储空间上保存。GitHub上都有详细的配置说明，大家依照说明来操作即可。需要注意的是，这里的空间名称是指你创建存储空间名称，密钥在七牛的“个人面板”里有个“密钥管理”，点击进去将其复制粘贴即可。dirPrefix的值的作用是将该属性值作为前缀添加到存储空间里文件名前。如，你上传了一个”aa.png”图片，在存储空间里保存的是”static/aa.png”。七牛存储空间不能建文件夹，因此通过前缀的形式来区分层级。配置完成后，本地的图片可以放在根目录下的static/images文件夹里，那么怎么保存到七牛空间里呢？这里通过$ hexo server即可将图片保存到七牛空间。图片的URL是http://your_site/static/images/yourimage.png。就是你的域名+自自定义的目录名+images+图片名。在文章里引用某张图片时，可以使用下面的写法也可以直接引用外链。暂时记录到这里，后续持续补充。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"实现一个函数clone，可以对js里五种主要的数据类型进行值复制？","date":"2017-03-18T07:26:58.000Z","path":"2017/03/18/实现一个函数对js里主要的数据类型进行值复制/","text":"问题：实现一个函数clone，可以对js里五种主要的数据类型进行值复制？考察点： 对于基本数据类型和引用数据类型在内存中存放的是值还是引用这一区别是否清楚； 怎样判断一个变量的类型； 递归算法的设计； 代码：12345678910111213141516function clone(obj)&#123; var obj2=&#123;&#125;; if (typeof obj !== &apos;object&apos;||obj==&apos;&apos;) &#123; return obj; &#125;else if (Object.prototype.toString.call(obj)==&apos;[object Array]&apos;) &#123; obj2=[]; for(var i in obj)&#123; obj2[i]=arguments.callee(obj[i]); &#125; &#125;else&#123; for(var i in obj)&#123; obj2[i]=arguments.callee(obj[i]); &#125; &#125; return obj2; &#125; 下面逐一来讲解考察知识点。 不同数据类型值的保存方式js数据类型分为基本数据类型和引用数据类型。基本数据类型有string,number,boolean,undefined,null。引用数据类型有object。 基本数据类型是以值的方式保存在内存中的。如1234var a = 1;var b = a;a = 2;console.log(b); 在这里，将a的值赋给b后，在内存中会新增空间存放这个值”1”。将a的值重置为2后，它对b是没有影响的，a和b的值是单独存储的。因此b依然为1。 在引用数据类型里，它传递的是关于对象的引用。1234var a = &#123;name:&apos;bird&apos;,age:12&#125;;var b = a;a.name = &apos;cat&apos;;console.log(b.name); 在这里，打印的结果是’cat’。变量a里保存的是对象的一个引用，当把a的值赋给b时，只是把这个引用赋给了b，它们都指向同一个内存。因此当重置a.name后，b.name也发生改变了。就像取昵称，你向不同的人展示不同的昵称，可是你这个人是独一无二的。 在我们这个问题里，要对不同数据类型的值进行复制，上面我们说了，引用数据类型如果直接赋给一个变量，它实际上复制的是引用。因此，我们需要将基本数据类型与引用数据类型分开复制。那么怎么判断一个变量的数据类型呢？ 判断变量的数据类型typeof基本数据类型可以通过”typeof”关键字来检查类型。typeof可返回如下值：”string,number,boolean,undefined,object,function”。其中”typeof null”返回的是”object”。 instanceofinstanceof用来判断一个变量是否是某个对象的实例。如12var a = new Object();a instanceof Object; //true 检测数组的方法通过”typeof”筛选出数据类型不是”object”或为null的数据，这些数据类型的数据在内存中存放的是值，因此可以直接return返回；剩下的有对象和数组，我们需要进一步区分。那么如何检测数组呢？ ECMAScript5的isArray函数 ECMAScript提供的Array.isArray(obj)可以用来检测一个对象是否是数组； 12var a = [1,2];Array.isArray(a); //true 这种方式检测数组的唯一缺陷是它的兼容性。IE9+、Firefox4+、Safari5+、Opera10.5+和Chrome都实现了这个方法，但是在IE8之前的版本是不支持的。 通过constructor属性来检测 对象都有一个constructor属性，指向它的构造函数。对于数组来说，它的内建对象是Array。通过该属性也可以检测数组类型。 12var a = [1,2];console.log(a.constructor == Array); //true instanceof操作符 instanceof操作符用来判断前面的对象是否是后面的类或对象的实例。 12var a = [1,2];console.log(a instanceof Array); 不过在有iframe存在时会出现问题。当你在多个frame中来回跳时，constructor和instanceof就不管用了。由于每一个frame都有自己的执行环境，跨frame实例化的对象彼此并不共享原型链，通过instanceof操作符和constructor属性检测的方法自然会失败。如下： 123456var iframe = document.createElement(&quot;iframe&quot;); //创建一个&quot;iframe&quot;标签document.body.appendChild(iframe); //将iframe添加到body里otherArray = window.frames[window.frames.length - 1].Array;//获取Array构造函数；var arr = new otherArray(&quot;1&quot;,&quot;2&quot;); //在iframe里实例化一个arr数组；console.log(arr instanceof Array); //falseconsole.log(arr instanceof otherArray); //true 因为arr数组是在框架里创建的，它是从iframe里的Array构造函数实例化而来（otherArray）的。 对象原生toString检测通过Object.prototype.toString来检测，它的工作原理是，先取得对象的一个内部属性[[Class]]，然后依据这个属性，返回一个类似于”[object Array]”的字符串作为结果（[[]]表示语言内部用到的、外部不可直接访问的属性）。利用这个方法，再配合call，我们可以取得任何对象的内部属性[[Class]]。然后把类型检测转化为字符串比较，以达到我们的目的。为什么不直接obj.toString()呢？虽然Array继承自Object（所有对象都继承Object()），内部也有toString方法，但是这个方法可能被改写达达不到我们的要求。检测数组方法可以参考(Javascript学习笔记：检测数组方法)[https://www.w3cplus.com/javascript/array-part-2.html] 这篇文章。 递归算法在程序中，递归就是函数直接调用自己或者间接调用自己。在我们这个题目里，通过for…in来遍历数组或对象。通过arguments.callee()来接收一个属性值，arguments.callee()的作用是调用当前正在执行的函数，也就是clone(obj)。这一操作的作用是，属性值可以是任何数据类型，它可能是一个对象，如果直接obj2[i] = obj[i]，那么复制的就是对象的引用了。所以我们需要对这个值再进行一次深度复制。即通过arguments.callee()来调用当前执行的函数。123for(var i in obj) &#123; obj2[i]=arguments.callee(obj[i]); &#125; 递归算法可以参考javascript递归算法的初步认识及使用技巧这篇文章。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"Hello World","date":"2017-03-17T07:26:58.000Z","path":"2017/03/17/hello-world/","text":"折腾了两三天，这个博客终于成型了。这是我的第一个个人博客，这个一个完全属于我的空间。要学习的东西还很多，要走的路还很长，特写此文，记录迈出的第一步。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]
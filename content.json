[{"title":"css动画里的steps()用法详解","date":"2017-03-30T07:53:40.000Z","path":"2017/03/30/css动画里的steps()用法详解/","text":"原文地址：http://designmodo.com/steps-css-animations/原文作者：Joni Trythall 我想你在css 动画里使用steps()会和我一样有很多困惑。一开始我不清楚怎样使用它，于是搜索出了两个案例：typing demo by Lea Verou 和 animated sprite sheet by Simurai. 这些例子很棒，帮助我开始理解这个特别的timming function，但是它们是如此优秀的例子，以至于在demo之外还是难以理解怎样使用steps()。 所以，我仔细研究了steps()并且做了一些动画demos用来帮助理解一些难点。 ##steps介绍##steps()是一个timing function，允许我们将动画或者过渡分割成段，而不是从一种状态持续到另一种状态的过渡。这个函数有两个参数——第一个参数是一个正值，指定我们希望动画分割的段数。 Steps(，) 第二个参数定义了这个要点 在我们的@keyframes中申明的动作将会发生的关键。这个值是可选的，在没有传递参数时，默认为”end”。方向为”start”表示一个左–持续函数，在动画开始时，动画的第一段将会马上完成。以左侧端点为起点，立即跳到第一个step的结尾处。它会立即跳到第一段的结束并且保持这样的状态直到第一步的持续时间结束。后面的每一帧都将按照此模式来完成动画。 方向为”end”表示一个右–持续函数。动画执行时，在每一帧里，动画保持当前状态直到这一段的持续时间完成，才会跳到下一步的起点，后面的每一帧都按照这个模式来进行，在最后一帧的起点，等到这一帧的持续时间结束，整个动画的执行也已经结束，执行动画的元素来不及跳到这一帧的终点，直接回到了整个动画起点，开始了第二次动画。每个选择本质上从一个不同的面移动这个元素并且将产生一个不同的位置在这个相同的动画里。这面是示例图： 动态解析图如下： ##填充模式和迭代次数的影响##在我们开始前，明白一个不同的填充模式或者迭代次数将会怎样影响steps()是非常重要的，例如”forwards”或者”infinite”的使用。如果我们有两辆车，使用相同的动画持续时间、相同的steps()值，但是其中一个设置（infinite），另一个填充（forward）,终点的这两辆汽车看起来非常不同，即使他们从相同的轴点出发。 “forwards”的命令使这个动画元素保持着@keyframes里最后一个动画样式。在动画，里将它与steps()联系使这个动作出现，好像初始的静止状态没有计算到总的步数里。当它是”end”，好像这个车行驶了额外的步数超出了你的steps()的声明，取决于你怎样看待它。 这些讲解听起来还是很散乱，但是我们将在demos里慢慢讲解。（demo地址：http://designmodo.com/demo/stepscss/）现在最重要的事情是留心这些变化将会怎样影响你的意图和steps数。下面是infinite VS forwards车： ##steps demos##你可以点击这里查看demos,它由以下几个部分组成： 纯css实现的闹钟 一些节能的css车 前进的熊爪印 纯css实现的进度圆 ###css闹钟### 一个应用了steps()的闹钟演示。我们需要闹钟的指针旋转起来，但是不是圆滑连续的运动。使用steps()将允许我们模仿真实的闹钟的运动。 这里涉及到了一些数学知识，但是还不是很痛苦。我们需要秒针通过60步完成360度的旋转在60s的时间里。 分针我们可以应用相同的@keyframes,只有改变动画的执行时间即可。分针转一圈，为3600s,即分针在3600s里，完成60步。 申明：这只是一个css闹钟，并不能依赖这个闹钟来执行你的日常活动。 ###css cars### css车演示了在steps()里使用”end”和”start”的不同。”start”使小车立即移动到一步的结束处并保持当前状态直到这一步的持续时间结束。看起来就好像使用了”start”的车的位置比使用”end”的车的位置更远，但是如果你给这两辆小车添加一个动画的延迟，你可以看到它们是从相同的起点出发的。 “end”会等到每一步的执行时间结束才会开始动画。第一辆车移动的时候，这是它的第二步，所以这两辆车没有机会同步移动。动画里白色的边框是动画当前的起始位置。 ###熊脚印### 另一种更好的理解stpes()的方法是创建真实的步数。这个案例我们将会使用熊脚印。这个演示使用了由六个脚印组成的图片。这个图片被一个覆盖，我们要用steps()移动这个来显示出脚印，用来模仿实际的脚印。 没有使用steps()时，将平滑的向右移动，这不是我们想要的效果。我们希望每个脚印可以立即完整的出现。 有六个脚印，我们需要向右移动的长度为图片的整个宽度。 我们的将向右移动675px在7秒7步的时间里。每一步是96px宽。”end”表示我们的动画将保持它的初始状态，覆盖扬剧有的脚印直到第一步完成。 ###css进度圆### 在这个演示里我们使用”start”来动态改变不透明度。使用”start”制作一个百分比的可见度的变化。 所有的百分数在同一个里，我们将这个通过动画向上移动380px；初始值是”20%”,我们需要通过四步移动使数值为40%,60%,80%到最后的100%。 再次强调，使用”forwards”和”infinite”对步数的的作用是不同的。如果我们改变成”infinite”，将不会出现”100%”,因为”forwards”命令使动画在我们设置的步数外添加了额外的一步。”forwards”使动画保持结束时的状态，所以在步数执行完毕后，动画会跳到最后一帧的状态并保持不变。 ##结束语##steps() timing function确实难以理解，但是一旦你掌握它了，就会有很多便利。css function 允许我们将动画切割成清楚的步数，或者创建平滑的动画效果。希望这些demos可以帮助你在动画里更好的理解使用steps()。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"实现一个函数对js里主要的数据类型进行值复制","date":"2017-03-29T01:27:58.000Z","path":"2017/03/29/实现一个函数对js里主要的数据类型进行值复制/","text":"问题：实现一个函数clone，可以对js里五种主要的数据类型进行值复制？考察点： 对于基本数据类型和引用数据类型在内存中存放的是值还是引用这一区别是否清楚； 怎样判断一个变量的类型； 递归算法的设计； 代码：12345678910111213141516function clone(obj)&#123; var obj2=&#123;&#125;; if (typeof obj !== &apos;object&apos;||obj==&apos;&apos;) &#123; return obj; &#125;else if (Object.prototype.toString.call(obj)==&apos;[object Array]&apos;) &#123; obj2=[]; for(var i in obj)&#123; obj2[i]=arguments.callee(obj[i]); &#125; &#125;else&#123; for(var i in obj)&#123; obj2[i]=arguments.callee(obj[i]); &#125; &#125; return obj2; &#125; 下面逐一来讲解考察知识点。 不同数据类型值的保存方式js数据类型分为基本数据类型和引用数据类型。基本数据类型有string,number,boolean,undefined,null。引用数据类型有object。 基本数据类型是以值的方式保存在内存中的。如1234var a = 1;var b = a;a = 2;console.log(b); 在这里，将a的值赋给b后，在内存中会新增空间存放这个值”1”。将a的值重置为2后，它对b是没有影响的，a和b的值是单独存储的。因此b依然为1。 在引用数据类型里，它传递的是关于对象的引用。1234var a = &#123;name:&apos;bird&apos;,age:12&#125;;var b = a;a.name = &apos;cat&apos;;console.log(b.name); 在这里，打印的结果是’cat’。变量a里保存的是对象的一个引用，当把a的值赋给b时，只是把这个引用赋给了b，它们都指向同一个内存。因此当重置a.name后，b.name也发生改变了。就像取昵称，你向不同的人展示不同的昵称，可是你这个人是独一无二的。 在我们这个问题里，要对不同数据类型的值进行复制，上面我们说了，引用数据类型如果直接赋给一个变量，它实际上复制的是引用。因此，我们需要将基本数据类型与引用数据类型分开复制。那么怎么判断一个变量的数据类型呢？ 判断变量的数据类型typeof基本数据类型可以通过”typeof”关键字来检查类型。typeof可返回如下值：”string,number,boolean,undefined,object,function”。其中”typeof null”返回的是”object”。 instanceofinstanceof用来判断一个变量是否是某个对象的实例。如12var a = new Object();a instanceof Object; //true 检测数组的方法通过”typeof”筛选出数据类型不是”object”或为null的数据，这些数据类型的数据在内存中存放的是值，因此可以直接return返回；剩下的有对象和数组，我们需要进一步区分。那么如何检测数组呢？ ECMAScript5的isArray函数 ECMAScript提供的Array.isArray(obj)可以用来检测一个对象是否是数组； 12var a = [1,2];Array.isArray(a); //true 这种方式检测数组的唯一缺陷是它的兼容性。IE9+、Firefox4+、Safari5+、Opera10.5+和Chrome都实现了这个方法，但是在IE8之前的版本是不支持的。 通过constructor属性来检测 对象都有一个constructor属性，指向它的构造函数。对于数组来说，它的内建对象是Array。通过该属性也可以检测数组类型。 12var a = [1,2];console.log(a.constructor == Array); //true instanceof操作符 instanceof操作符用来判断前面的对象是否是后面的类或对象的实例。 12var a = [1,2];console.log(a instanceof Array); 不过在有iframe存在时会出现问题。当你在多个frame中来回跳时，constructor和instanceof就不管用了。由于每一个frame都有自己的执行环境，跨frame实例化的对象彼此并不共享原型链，通过instanceof操作符和constructor属性检测的方法自然会失败。如下： 123456var iframe = document.createElement(&quot;iframe&quot;); //创建一个&quot;iframe&quot;标签document.body.appendChild(iframe); //将iframe添加到body里otherArray = window.frames[window.frames.length - 1].Array;//获取Array构造函数；var arr = new otherArray(&quot;1&quot;,&quot;2&quot;); //在iframe里实例化一个arr数组；console.log(arr instanceof Array); //falseconsole.log(arr instanceof otherArray); //true 因为arr数组是在框架里创建的，它是从iframe里的Array构造函数实例化而来（otherArray）的。 对象原生toString检测通过Object.prototype.toString来检测，它的工作原理是，先取得对象的一个内部属性[[Class]]，然后依据这个属性，返回一个类似于”[object Array]”的字符串作为结果（[[]]表示语言内部用到的、外部不可直接访问的属性）。利用这个方法，再配合call，我们可以取得任何对象的内部属性[[Class]]。然后把类型检测转化为字符串比较，以达到我们的目的。为什么不直接obj.toString()呢？虽然Array继承自Object（所有对象都继承Object()），内部也有toString方法，但是这个方法可能被改写达达不到我们的要求。检测数组方法可以参考(Javascript学习笔记：检测数组方法)[https://www.w3cplus.com/javascript/array-part-2.html] 这篇文章。 递归算法在程序中，递归就是函数直接调用自己或者间接调用自己。在我们这个题目里，通过for…in来遍历数组或对象。通过arguments.callee()来接收一个属性值，arguments.callee()的作用是调用当前正在执行的函数，也就是clone(obj)。这一操作的作用是，属性值可以是任何数据类型，它可能是一个对象，如果直接obj2[i] = obj[i]，那么复制的就是对象的引用了。所以我们需要对这个值再进行一次深度复制。即通过arguments.callee()来调用当前执行的函数。123for(var i in obj) &#123; obj2[i]=arguments.callee(obj[i]); &#125; 递归算法可以参考javascript递归算法的初步认识及使用技巧这篇文章。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"hexo搭建博客过程","date":"2017-03-18T07:26:58.000Z","path":"2017/03/18/hexo搭建博客过程/","text":"其实hexo搭建博客超级简单。不过因为开始对这个不熟悉，跟着网上找到的教程操作反而入了很多坑。这篇文章算是做个总结吧。下面分几个阶段逐渐由简入深来讲解。 快速熟悉hexohexo博客成型 打开hexo官方文档，根据”安装前提”检查是否已经安装需要的应用程序。都安装好了后，按照文档上的步骤建站。 执行完上面命令后，接着执行以下命令，这行命令的作用是生成我们在浏览器里看到的html静态文件。$ hexo generate该命令可以简写为$ hexo g 怎么在本地查看这些页面呢？那么需要搭建一个服务器。hexo提供了”hexo-server”模块，通过以下命令来安装。$ npm install hexo-server --save安装完成后，在命令行里输入以下命令可启动服务器$ hexo server执行完命令后，在浏览器里输入 http://localhost:4000 即可查看网站。在服务器启动期间，hexo会监视文件变动并自动更新，您无须重启服务器。注意：有时在端口4000下很长时间无法加载出页面，此时可以试着更换端口。如下：$ npm server -p 5000完成上述步骤后，在浏览器里可以看到如下界面： 一个hexo默认的博客已经成型了。 配置博客默认博客生成了，那么怎么将它变成你的个人定制博客呢？我们需要对生成的 _config.yml 文件进行修改。具体可查看文档里的配置章节。这里有点需要注意的是，键值对中，冒号后面跟一个空格即可。除了常规配置外，hexo还为我们提供了很多 Hexo主题。根据自己的喜好选择主题，clone下来的主题会在themes文件夹里。将根目录下的_config.yml里的theme值修改成你选择要应用的主题名，然后进入到themes相应主题里，对主题里的_config.yml进行配置。这些工作都完成后了该怎么来查看效果呢？我们先用$ hexo clean清理已经生成的静态文件，然后执行$ hexo g$ npm server -p 5000在浏览器里就可以查看啦。 将hexo部署到github到目前为止，我们的个人博客只能在本地查看，怎么实现通过域名来访问个人博客呢？当然可以通过购买域名和空间来实现，我们也可以利用GitHub免费实现。GitHub为每一个用户分配了一个二级域名.github.io，用户为自己的二级域名创建主页很容易，只要在托管空间下创建一个名为.github.io的版本库，向其master分支提交网站静态页面即可。需要注意的一个是，是你的用户名。创建好了版本库，接下来就是要把生成的静态页面部署到GitHub版本库上了。打开根目录下的_config.yml文件，找到deploy设置如下,根据你的用户名来设置。注意空格缩进。1234deploy: type: git repo: git@github.com:&lt;user-id&gt;/&lt;user-id&gt;.github.io.git branch: master 到目前，准备工作已经全部完成。在Git Bash里输入：123$ hexo clean$ hexo g$hexo d 如果看到”Deploy done: git”即表示部署成功。打开GitHub里.github.io版本库，找到”Settings”，点击进去，在”GitHub Pages”模块，有”Your site is published at ……”，点击这个链接，即可查看你部署成功后的博客。 给博客绑定个人域名通过GitHub主页来访问，域名有些长，而且一看就知道是存放Github上。可能我们会想绑定自己的独立域名，拥有属于自己的独立博客。前提当然是你有个已经购买了的域名。我是在腾讯云买的域名，下面就讲讲在腾讯云里怎么设置。登录后，找到“云解析”模块，选择你要解析的域名，在操作里点击“解析”——“添加记录”。记录类型选择”CNAME”，它的作用是将域名指向另一个域名。主机记录默认，记录值填GitHub提供的个人主页域名，如”yang.github.io”。其它默认，保存。再添加一个记录，主机记录填写”www”，其它同上，保存。回到GitHub里.github.io版本库，在右上角点击”Create new file”，将文件命名为”CNAME”，里面写入你刚才解析过的域名。如：”auraty.com”。等10分钟后，在浏览器里就可以直接通过”auraty.com”来访问我的个人博客啦。 写文章会遇到的坑插入图片GitHub为个人提供了300M的免费空间，如果博客图片很多的话，加载会很慢，空间内存不够。而且HTTP并行下载的资源数量一般为10个左右，所以建议将网站资源放在多个域名中。因此我们可以将代码保存在GitHub中，将照片放在七牛中。你可以通过邀请链接进行注册，注册完成后，在“资源主页”里选择“对象存储”——“立即添加”，输入相关信息后保存即建好了存储空间。回到我们的博客源码所在文件夹，我在这里使用的是网上的一个hexo插件hexo-qiniu-syn，它的作用是将图片、js、css等一些静态文件上传到七牛的存储空间上保存。GitHub上都有详细的配置说明，大家依照说明来操作即可。需要注意的是，这里的空间名称是指你创建存储空间名称，密钥在七牛的“个人面板”里有个“密钥管理”，点击进去将其复制粘贴即可。dirPrefix的值的作用是将该属性值作为前缀添加到存储空间里文件名前。如，你上传了一个”aa.png”图片，在存储空间里保存的是”static/aa.png”。七牛存储空间不能建文件夹，因此通过前缀的形式来区分层级。配置完成后，本地的图片可以放在根目录下的static/images文件夹里，那么怎么保存到七牛空间里呢？这里通过$ hexo server即可将图片保存到七牛空间。图片的URL是http://your_site/static/images/yourimage.png。就是你的域名+自自定义的目录名+images+图片名。在文章里引用某张图片时，可以使用下面的写法也可以直接引用外链。暂时记录到这里，后续持续补充。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Hello World","date":"2017-03-17T07:26:58.000Z","path":"2017/03/17/hello-world/","text":"折腾了两三天，这个博客终于成型了。这是我的第一个个人博客，这个一个完全属于我的空间。要学习的东西还很多，要走的路还很长，特写此文，记录迈出的第一步。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]